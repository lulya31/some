---
title: "TypeScript"
description: "Описание TypeScript"
weight: 2
draft: false
---

:imgdir: /02_01_05_02_img/
:imagesoutdir: ./static/02_01_05_02_img/

include::static/includes/init.adoc[]

= TypeScript

{empty} +

== Что такое TypeScript?

****
*TypeScript* — это язык со статической типизацией на основе *JavaScript*. Он создан в 2012 году в компании *Microsoft*. Разработкой *TypeScript* занимался Андрес Гейлсберг (он был ведущим архитектором *C#* и *Delphi*, а также создал *Turbo Pascal*).
****

****
.Отношение *JavaScript* и *TypeScript*
[[typescript_1_anchor]]
[%collapsible%open]
====
image::typescript_1.png[title="Отношение *JavaScript* и *TypeScript*", align=center]
====
****

=== Строгая типизация

****
Для переменных и других структур данных можно объявить определенный тип, например, строковый или булевский, и *TypeScript* будет проверять, допустимые ли значения им присваиваются. Это невозможно сделать в *JavaScript*, в котором типизация нестрогая.

{empty} +

В *TypeScript* можно явно указать тип переменной. Когда тип переменной определен, ей невозможно присвоить значение, которое относится к другому типу.
****

=== Расширенные возможности ООП

****
В *TypeScript* реализованы дополнительные возможности *ООП* (**О**бъектно **О**риентированное **П**рограммирование), такие как интерфейсы, поля объекта и модификаторы доступа.

Интерфейс определяется с помощью ключевого слова `[.red]#interface#`.
****

[source, typescript]
----
// Определить интерфейс домашнего животного
interface IPet {
    name: string,
    species: string,
    breed: string,
    speak: () => string
}

// Создать пса
var dog:IPet = {
    name: "Ritchie Blaсkdog",
    species: "dog",
    breed: "hellhound",
    speak: ():string =>
        {return "Woof! Woof-woof-woof!"}
}
----

****
Поля и модификаторы доступа:
****

[source, typescript]
----
class User {
    // Поля будут приватными
    private name: string;
    private password: string;

    constructor(name: string, password: string){
        this.name = name;
        this.password = password;
    }

    // Доступ для чтения открыт
    public get Name(): string{
        return this.name;
    }

    public get Password(): string{
        return this.password;
    }
}
----

== Отличия TypeScript от JavaScript

****
*JavaScript* создан для написания небольших сценариев WEB-страниц. Чем крупнее приложение, тем более громоздким становится код на *JS*. Поэтому был создан *TypeScript*, который упрощает разработку широкомасштабных приложений. Из-за нестрогой типизации в *JavaScript* многие ошибки видны только во время выполнения. Это неудобно и, в конце концов, неприятно. Приходится тратить много времени на поиск таких ошибок. *TypeScript* устраняет этот недостаток: написанный на нем сценарий не сможет случайно вызвать переменную как функцию или запросить значение поля, если оно не определено в объекте. Вы увидите превентивное сообщение об ошибке уже во время набора кода (рисунок 1).
****

****
.Ошибки видны во время разработки
[[typescript_2_anchor]]
[%collapsible%open]
====
image::typescript_2.png[title="Ошибки видны во время разработки", align=center]
====
****

****
В *TypeScript* реализована поддержка интерфейсов и модификаторов доступа, обобщений, модулей, пространств имен и окружений (*ambients*). В *JavaScript* этого нет.
****

====
IMPORTANT: *Код JavaScript — интерпретируемый язык. Он воспринимается браузерами напрямую. TypeScript компилируется в JavaScript.*
====

== Особенности TypeScript

=== Объявления типов

****
В *TypeScript* можно объявить переменную четырьмя способами: с указанием типа и значения, с указанием только типа, с указанием только значения — и без типа, и без значения.
****

[source, typescript]
----
// Объявить тип и значение в одном операторе.
var amount:number = 10000.00;

/* Объявить тип, не присваивая значения.
  По умолчанию переменной будет присвоено значение undefined. */
var amount:number;

/* Объявить значение, не задавая тип.
  Переменная получит тип присвоенного значения. */
var amount = 10000.00;

/* Не указывать ни типа, ни значения.
  В этом случае переменная получит тип any и значение undefined. */
var amount;
----

====
NOTE: После того как объявлен тип переменной, ей *невозможно* присвоить значение другого типа.
====

****
Но если, все-таки, необходимо изменить тип переменной, то можно воспользоваться утверждением типа (`[.red]#type assertion#`). Для этого нужно заключить требуемый тип в символы `[.red]#< >#` и поместить перед переменной или выражением.
****

[source, typescript]
----
var x = '1'
var y:number = <number> <any> x
console.log(typeof(y))
----

****
Приведенный выше код выведет в консоль строку *«string»*.

{empty} +

Рассмотрим типы данных, определенные в *TypeScript*.
****

==== Any

****
Тип *any* — это надтип для всех типов в *TypeScript*, динамический тип. Его использование подразумевает отказ от проверки типа переменной.
****

==== Встроенные типы

****
В приведенной ниже link:#table_1_anchor[таблице 1] перечислены встроенные типы *TypeScript* и даны их описания.
****

.Встроенные типы TypeScript и их описания
[[table_1_anchor]]
[cols="^.^15h,.^85"]
|===
| Ключевое слово | Описание

| number | 64-разрядные числовые значения с плавающей точкой. Используются для представления как целых, так и дробных чисел.
| string | Последовательность символов *Unicode*.
| boolean | Логическое значение: `[.red]#true#` или `[.red]#false#`
| void | Тип возврата для функций, которые не возвращают значения
| null | Явное указание отсутствия значения объекта.
| undefined | Значение, присваиваемое всем переменным до их инициализации
|===

==== Пользовательские типы

****
В приведенной ниже link:#table_2_anchor[таблице 2] перечислены пользовательские типы *TypeScript* и даны их описания.
****

.Пользовательские типы TypeScript и их описания
[[table_2_anchor]]
[cols="^.^25,.^75"]
|===
| Ключевое слово | Описание

| *Массив* (`[.red]#array#`) и *Кортеж* (`[.red]#tuple#`) | Эти типы позволяют хранить множеству несколько значений в заданной последовательности. Массив состоит из элементов одного типа, а кортеж может содержать значения нескольких разных типов. Для обращения к каждому элементу массива используется метод *TypeScript* `[.red]#forEach()#`.
| *Перечисление* (`[.red]#enum#`) | Как и в *C#*, *enum* дает возможность присвоить удобочитаемые имена последовательности числовых значений.
| *Объединение* (`[.red]#union#`) | Начиная с *TypeScript 1.4* можно комбинировать типы, благодаря чему переменная может принимать значение, относящееся к одному из них.
| *Объект* (`[.red]#object#`) | Представляет собой любое значение, не относящееся к примитивному типу.
|===

==== Литералы типов

****
Типами в *TypeScript* могут быть не только строки вообще (`[.red]#string#`) или числа вообще (`[.red]#number#`). Конкретное число или конкретная строка тоже может быть типом. Например, типом может быть *«8»*, а может быть *«красный»*. Если переменная объявлена с литералом типа, то она не может принимать никакие другие значения.

{empty} +

Рассмотрим это на примере кода:
****

[source, typescript]
----
let red:"красный" = "красный";
red = "красный";
red = "зеленый";
----

****
При попытке его скомпилировать получим ошибку:
****

****
.Ошибка компеляции
[[typescript_3_anchor]]
[%collapsible%open]
====
image::typescript_3.png[title="Ошибка компеляции", align=center]
====
****

****
И для чего же нужна переменная с уникальным типом и единственным значением? Сама по себе она не особо полезна. Дело в применении. Например, в *CSS* есть свойства, которые принимают лишь несколько определенных значений. Свойство *alignment* может принимать значения *left*, *right* или *center*.
Если объединить литералы типов *left*, *right* и *center* (которые объявлены как строки) в *union*, то получим двойную пользу:

{empty} +

====
* Будут приниматься лишь допустимые значения
* Они будут передаваться в виде строк, которые можно вставить в код (не нужно ветвление, чтобы сопоставить значения из объединения со строковыми значениями)
====

Наглядно это будет выглядеть так:
****

[source, typescript]
----
function setText(msg: string, alignment: "left" | "right" | "center") {
 // ...
}
setText("Готово!", "left");
setText("Ошибка!", "bottom");
----

.*Компилятор не дает ошибиться!*
****
.Компилятор не дает ошибиться!
[[typescript_4_anchor]]
[%collapsible%open]
====
image::typescript_4.png[title="Компилятор не дает ошибиться!", align=center]
====
****

==== Шаблоны литералов типов

****
Шаблоны — это надстройка над литералами типов. Благодаря объединениям они могут разворачиваться во множество строк без необходимости в циклах.

{empty} +

В шаблонах литеральных типов используется тот же синтаксис, что и в шаблонах литералов строк JavaScript, но с указанием типов, а не переменных.
****

****
.Шаблоны литералов типов
[[typescript_5_anchor]]
[%collapsible%open]
====
image::typescript_5.png[title="Шаблоны литералов типов", align=center]
====
****

****
Если же тип определен в виде объединения, то типу присваивается каждый возможный литерал из комбинаций членов объединения.
****

****
.Присвоение типа каждому литералу
[[typescript_6_anchor]]
[%collapsible%open]
====
image::typescript_6.png[title="Присвоение типа каждому литералу", align=center]
====
****

****
Если добавить еще один критерий, например, валюту, то будет создано множество из всех возможных комбинаций.
****

****
.Создание множества
[[typescript_7_anchor]]
[%collapsible%open]
====
image::typescript_7.png[title="Создание множества", align=center]
====
****

****
То есть, весь список значений для этого типа будет таким:
****

[source, typescript]
----
type cardsByCurrencies = "USD_prepaid_visa" | "USD_prepaid_mastercard" | "USD_credit_visa" | "USD_credit_mastercard" | "EUR_prepaid_visa" | "EUR_prepaid_mastercard" | "EUR_credit_visa" | "EUR_credit_mastercard"
----

****
Необходимо также заметить, что и в литералах типов, равно как и в шаблонах, может использоваться вывод типов. Подробнее см. в link:https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html[документации, window=_blank].
****

==== Классы

****
*TypeScript* — это объектно-ориентированный *JavaScript*. Он поддерживает классы, интерфейсы и т. п. *TypeScript* получил поддержку классов от *ES6*.
****

==== Объявление класса

****
Для объявления класса используется ключевое слово `[.red]#class#`.
****

[source, typescript]
----
class User {
// Область видимости класса
}
----

****
Приведенный выше код компилируется в такой код *JavaScript*.
****

[source, javascript]
----
var User = /** @class */ (function () {
function User() {
}
return User;
}());
----

****
Приведем пример объявления класса с полями, конструктором и функцией.
****

[source, typescript]
----
class Person {
    // Поле
    firstName: string;
    lastName:  string;

    // Конструктор
    constructor(firstName:string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    // Функция
    logFullName(): void {
        console.log(${this.firstName} ${this.lastName});
    }
}
----

****
На *JavaScript* этот код будет выглядеть так:
****

[source, javascript]
----
var Person = /** @class */ (function () {
   // Конструктор
    function Person(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
   // Функция
    Person.prototype.logFullName = function () {
        console.log("".concat(this.firstName, " ").concat(this.lastName));
    };
    return Person;
}());
----

==== Создание экземпляра класса

****
Экземпляр класса в TypeScript создается с помощью ключевого слова `[.red]#new#`.
****

[source, typescript]
----
var p = new Person('Mickey', 'Mouse');
----

==== Доступ к полям и функциям

****
Для обращения к полям и функциям используется запись с точкой.
****

[source, typescript]
----
p.firstName;
p.logFullName();
----

****
Сведем все воедино:
****

[source, typescript]
----
class Person {
    // Поле
    firstName: string;
    lastName:  string;

    // Конструктор
    constructor(firstName:string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    // Функция
    logFullName(): void {
        console.log({this.firstName} ${this.lastName});
    }
}

var p = new Person('Mickey', 'Mouse');
console.log(Имя:     ${p.firstName});
console.log(Фамилия: ${p.lastName});
console.log('Полное имя:');
p.logFullName();
----

****
Код *JavaScript*:
****

[source, javascript]
----
var Person = /** @class */ (function () {
   // Конструктор
    function Person(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
   // Функция
    Person.prototype.logFullName = function () {
        console.log("".concat(this.firstName, " ").concat(this.lastName));
    };
    return Person;
}());
var p = new Person('Mickey', 'Mouse');
console.log("\u0418\u043C\u044F:     ".concat(p.firstName));
console.log("\u0424\u0430\u043C\u0438\u043B\u0438\u044F: ".concat(p.lastName));
console.log('Полное имя:');
p.logFullName();
----

.Вывод
****
.Вывод
[[typescript_8_anchor]]
[%collapsible%open]
====
image::typescript_8.png[title="Вывод", align=center]
====
****

****
Как видите, если вы знакомы с *ООП* и *JavaScript*, все довольно просто.
****

=== Пространства имен

****
Пространства имен — это способ логической группировки взаимосвязанного кода. Это встроенная возможность *TypeScript*. В *JavaScript* пространства имен отсутствуют, поэтому может возникнуть конфликт имен, если в нескольких файлах встретятся переменные с одним и тем же именем.

{empty} +

Пример:
****

.Файл conflict.html
[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Конфликт имен в JavaScript</title>
    <script src="scr1.js"></script>
    <script src="scr2.js"></script>
    <script>
        console.log("Inline script:");
        console.log(text);
    </script>
</head>
<body>
    <div id="target1"></div>
    <div id="target2"></div>
    <div id="target3"></div>
</body>
</html>
----

.Файл scr1.js
[source, javascript]
----
var text = "Text from scr1.js";
console.log(text);
----

.Файл scr2.js
[source, javascript]
----
var text = "Text from scr2.js";
console.log(text);
----

****
Первым импортируется файл *scr1.js*, вторым — *scr2.js*, поэтому вложенный сценарий, объявленный после импорта двух внешних, получит переменную `[.red]#text#` со значением, которое присвоено в *scr2.js*.
****

****
.Значение переменной `[.red]#text#`
[[typescript_9_anchor]]
[%collapsible%open]
====
image::typescript_9.png[title="Значение переменной `[.red]#text#`", align=center]
====
****

****
*TypeScript* устраняет этот недостаток за счет пространств имен. Термин «пространство имен» введен в *TypeScript 1.5*. До этой версии в TypeScript были внутренние и внешние модули. Теперь внутренние модули называются пространствами имен, а внешние — просто модулями.
****

****
Для определения пространства имен используется ключевое слово `[.red]#namespace#`. Классы и интерфейсы, к которым будут обращаться извне модуля, необходимо пометить ключевым словом `[.red]#export#`.
****

[source, typescript]
----
namespace MyNameSpaceName {
export MyClassName { }
export IMyInterfaceName { }
}
----

****
Для доступа к классу или интерфейсу, которые находятся в другом пространстве имен, используется запись с точкой: `[.red]#namespaceName.className#`.

{empty} +

Если пространство имен находится в другом файле, то необходимо указать ссылку на этот файл, используя запись с тремя косыми чертами:
****

[source, typescript]
----
/// <reference path = "SomeFileName.ts" />
----

****
Объявим переменные с одним и тем же именем в разных пространствах имен.
****

.Файл animals.ts
[source, typescript]
----
namespace Animals {
export let count = 12;
}
----

.Файл people.ts
[source, typescript]
----
namespace People {
export let count = 3;
}
----

.Файл howmany.ts
[source, typescript]
----
/// <reference path = "./people.ts" />
/// <reference path = "./animals.ts" />
console.log(People.count);
console.log(Animals.count);
----

****
Скомпилируем эти файлы в код *JavaScript*. Для этого передадим команде `[.red]#tsc#` параметр `[.red]#--outFile#`, за которым указывается имя целевого файла *JavaScript*, а затем перечисляются файлы *TypeScript*.
****

[source, bash]
----
npx tsc --outFile howmany.js howmany.ts animals.ts people.ts
----

****
Получим следующий код *JavaScript*:
****

[source, javascript]
----
var People;
(function (People) {
    People.count = 3;
})(People || (People = {}));
var Animals;
(function (Animals) {
    Animals.count = 12;
})(Animals || (Animals = {}));
/// <reference path = "./people.ts" />
/// <reference path = "./animals.ts" />
console.log(People.count);
console.log(Animals.count);
----

****
Соответственно, результаты вывода значения `[.red]#count#` будут разными: *3* и *12*.
****

==== Возможности пространств имен в TypeScript

****
* Пространство имен можно расположить в отдельном файле, который подключается с помощью ссылки
* Пространства имен можно вкладывать друг в друга. Вложенные пространства имен помечаются ключевым словом export
* В одном файле можно объявить несколько пространств имен
* Пространство имен можно разбить на несколько файлов, приводя ссылку на основной файл в каждом дополнительном;
* Чтобы не набирать долгие пути к классам, можно объявить псевдоним импортируемого класса. Например, если у нас есть пространство имен `[.red]#Data#`, в которое вложено пространство имен `[.red]#Animal#` с классом `[.red]#Dog#`, то псевдоним можно объявить так: `[.red]#import dog = Data.Animal.Dog#`. Тогда можно будет обращаться к полям и методам этого класса через префикс `[.red]#dog#`.
****

=== Модули

****
Модули помогают упорядочить код, написанный на *TypeScript*. До *TypeScript 1.5* модули делились на внутренние и внешние. С *версии 1.5* внутренние модули называются пространствами имен, а внешние — собственно модулями.

{empty} +

Модулем считается любой файл с импортом или экспортом на высшем уровне. Модули выполняются в собственной области видимости.

{empty} +

Файл без импорта и экспорта на высшем уровне считается сценарием, чье содержимое доступно в глобальной области видимости.
****

****
Чтобы интерфейс, класс, переменную или функцию можно было использовать в другом файле, перед объявлением добавляется ключевое слово `[.red]#export#` (как это делалось в примере с пространствами имен). Но вместо того, чтобы добавлять его к каждому объявлению, можно использовать более простую и наглядную запись, объединяя классы, интерфейсы и т. п.:
****

[source, typescript]
----
export { Dog, move };
----

****
Модуль импортируется с помощью ключевого слова `[.red]#import#`:
****

[source, typescript]
----
import { Dog, move } from "./myfile.js";
----

****
При импорте можно указывать псевдонимы с помощью ключевого слова `[.red]#as#` (его также можно использовать для создания псевдонима при экспорте):
****

[source, typescript]
----
import { Dog, move as myMove } from "./myfile.js";
----

****
Можно импортировать модуль целиком в одно пространство имен:
****

[source, typescript]
----
import * as mymodule from "./myfile.js";
----

****
В конце концов, можно указать один класс как экспортируемый по умолчанию. Для этого после слова export указывается слово default. При этом данный класс будет импортироваться по умолчанию, даже если в операторе импорта указан псевдоним.
****

=== Совместимость с JavaScript. Окружение (Ambient)

****
*JavaScript* — это подмножество *TypeScript*. Казалось бы, если в сценарии *TS* есть код *JS*, то компилятор *TypeScript* примет его без проблем. Это справедливо, если код *JavaScript* написан с учетом безопасности с точки зрения типов.

{empty} +

Другое дело, если вы используете большие библиотеки *JS* или сторонние, например *jQuery*, *Node.js* или *AngularJS* (именно *AngularJS*, потому что библиотека *Angular* написана на *TypeScript*). Чтобы обеспечить безопасность типов и ввод с автодополнением (`[.red]#intellisense#`), *TypeScript*-программисту придется приложить нечеловеческие усилия.

{empty} +

Объявления окружения (`[.red]#ambient#`) помогают беспроблемно встраивать библиотеки *JS* в *TypeScript*. Определения окружений по соглашению помещаются в файл определения типов в расширением `[.red]#d.ts#`, например `[.red]#ThirdPartyLib.d.ts#`. Этот файл не компилируется в *JavaScript*.
****

.Переменные и модули определяются так:
[source, javascript]
----
declare module Module_Name {
    export class SomeClass{
        doSmth(times:number) : number;
    }
}
----

****
В файле окружения нет реализации. В нем объявляются типы. Затем они включаются в файл *TypeScript* следующим образом:
****

[source, javascript]
----
/// <reference path = "ThirdPartyLib.d.ts" />
----

****
В результате при попытке передать функции `[.red]#doSmth#` строковое значение будет выдано сообщение об ошибке — еще во время компиляции. +
Таким образом можно состыковывать сторонние библиотеки с кодом *TypeScript* и не беспокоиться о том, что код поведет себя непредсказуемо.
****

== Преимущества и недостатки TypeScript

.Преимущества *TypeScript* составляют, среди прочих, его следующие особенности:
****
====
. Возможность выявлять ошибки еще в редакторе кода и во время компиляции
. Поддержка *ООП*
. Удобная система типов
. Пригодность для разработки крупных проектов
====
****

.Недостатки *TypeScript*, на наш взгляд, таковы:
****
====
. Снижает скорость разработки за счет необходимости указания типов
. Компиляция существенно замедляет сборку, особенно если речь идет о больших проектах
. Необходимость самостоятельно прописывать сигнатуры для внешних библиотек
. Порог входа повышен: в *TypeScript* столько нововведений, что его освоение можно сравнить с изучением нового языка
====
****

== Итоги

****
*TypeScript* позволяет избегать ошибок уже в начале разработки проекта, что избавляет от непредвиденных затрат. *TypeScript* можно представить себе как безопасное расширение, своего рода апгрейд для старого-доброго *Javascript*, программирование в котором давно уже имеет довольно недобрую репутацию. В *TypeScript* реализовано много интересных и полезных возможностей. В любом случае знакомство с этим языком идет на пользу, и если вдруг появится возможность работать над крупным фронтенд-проектом на *TypeScript*, вы будете заранее готовы.
****
