---
title: "TypeScript"
description: "Описание TypeScript"
weight: 2
draft: false
---

:toc: auto
:toc-title: Содержание
:toclevels: 5
:doctype: book
:icons: font
:figure-caption: Рисунок
:table-caption: Таблица
:source-highlighter: pygments
:pygments-css: style
:pygments-style: monokai
:includedir: ./content/

:imgdir: /02_01_05_02_img/
:imagesdir: {imgdir}
ifeval::[{exp2pdf} == 1]
:imagesdir: static{imgdir}
:includedir: ../
endif::[]

:imagesoutdir: ./static/02_01_05_02_img/

= TypeScript

{empty} +

== Что такое TypeScript?

****
*TypeScript* — это язык со статической типизацией на основе *JavaScript*. Он создан в 2012 году в компании *Microsoft*. Разработкой *TypeScript* занимался Андрес Гейлсберг (он был ведущим архитектором *C#* и *Delphi*, а также создал *Turbo Pascal*).
****

****
.Отношение JavaScript и TypeScript
[[typescript_1_anchor]]
[%collapsible%open]
====
image::typescript_1.png[title="Отношение JavaScript и TypeScript", align=center]
====
****

=== Строгая типизация

****
Для переменных и других структур данных можно объявить определенный тип, например, строковый или булевский, и *TypeScript* будет проверять, допустимые ли значения им присваиваются. Это невозможно сделать в *JavaScript*, в котором типизация нестрогая.

{empty} +

В *TypeScript* можно явно указать тип переменной. Когда тип переменной определен, ей невозможно присвоить значение, которое относится к другому типу.
****

=== Расширенные возможности ООП

****
В *TypeScript* реализованы дополнительные возможности *ООП* (*О*бъектно *О*риентированное *П*рограммирование), такие как интерфейсы, поля объекта и модификаторы доступа.

Интерфейс определяется с помощью ключевого слова `interface`.
****

[source, typescript]
----
// Определить интерфейс домашнего животного
interface IPet {
    name: string,
    species: string,
    breed: string,
    speak: () => string
}

// Создать пса
var dog:IPet = {
    name: "Ritchie Blaсkdog",
    species: "dog",
    breed: "hellhound",
    speak: ():string =>
        {return "Woof! Woof-woof-woof!"}
}
----

****
Поля и модификаторы доступа:
****

[source, typescript]
----
class User {
    // Поля будут приватными
    private name: string;
    private password: string;

    constructor(name: string, password: string){
        this.name = name;
        this.password = password;
    }

    // Доступ для чтения открыт
    public get Name(): string{
        return this.name;
    }

    public get Password(): string{
        return this.password;
    }
}
----

== Отличия TypeScript от JavaScript

****
*JavaScript* создан для написания небольших сценариев WEB-страниц. Чем крупнее приложение, тем более громоздким становится код на *JS*. Поэтому был создан *TypeScript*, который упрощает разработку широкомасштабных приложений. Из-за нестрогой типизации в *JavaScript* многие ошибки видны только во время выполнения. Это неудобно и, в конце концов, неприятно. Приходится тратить много времени на поиск таких ошибок. *TypeScript* устраняет этот недостаток: написанный на нем сценарий не сможет случайно вызвать переменную как функцию или запросить значение поля, если оно не определено в объекте. Вы увидите превентивное сообщение об ошибке уже во время набора кода (рисунок 1).
****

****
.Ошибки видны во время разработки
[[typescript_2_anchor]]
[%collapsible%open]
====
image::typescript_2.png[title="Ошибки видны во время разработки", align=center]
====
****

****
В *TypeScript* реализована поддержка интерфейсов и модификаторов доступа, обобщений, модулей, пространств имен и окружений (*ambients*). В *JavaScript* этого нет.
****

====
IMPORTANT: *Код JavaScript — интерпретируемый язык. Он воспринимается браузерами напрямую. TypeScript компилируется в JavaScript.*
====

== Особенности TypeScript

=== Объявления типов

****
В *TypeScript* можно объявить переменную четырьмя способами: с указанием типа и значения, с указанием только типа, с указанием только значения — и без типа, и без значения.
****

[source, typescript]
----
// Объявить тип и значение в одном операторе.
var amount:number = 10000.00;

/* Объявить тип, не присваивая значения.
  По умолчанию переменной будет присвоено значение undefined. */
var amount:number;

/* Объявить значение, не задавая тип.
  Переменная получит тип присвоенного значения. */
var amount = 10000.00;

/* Не указывать ни типа, ни значения.
  В этом случае переменная получит тип any и значение undefined. */
var amount;
----

====
NOTE: После того как объявлен тип переменной, ей *невозможно* присвоить значение другого типа.
====

****
Но если, все-таки, необходимо изменить тип переменной, то можно воспользоваться утверждением типа (`type assertion`). Для этого нужно заключить требуемый тип в символы `< >` и поместить перед переменной или выражением.
****

[source, typescript]
----
var x = '1'
var y:number = <number> <any> x
console.log(typeof(y))
----

****
Приведенный выше код выведет в консоль строку *«string»*.

{empty} +

Рассмотрим типы данных, определенные в *TypeScript*.
****

==== Any

****
Тип *any* — это надтип для всех типов в *TypeScript*, динамический тип. Его использование подразумевает отказ от проверки типа переменной.
****

==== Встроенные типы

****
В приведенной ниже link:#table_1_anchor[таблице 1] перечислены встроенные типы *TypeScript* и даны их описания.
****

.Встроенные типы TypeScript и их описания
[[table_1_anchor]]
[cols="^.^15h,.^85"]
|===
| Ключевое слово | Описание

| number | 64-разрядные числовые значения с плавающей точкой. Используются для представления как целых, так и дробных чисел.
| string | Последовательность символов *Unicode*.
| boolean | Логическое значение: `true` или `false`
| void | Тип возврата для функций, которые не возвращают значения
| null | Явное указание отсутствия значения объекта.
| undefined | Значение, присваиваемое всем переменным до их инициализации
|===

==== Пользовательские типы

****
В приведенной ниже link:#table_2_anchor[таблице 2] перечислены пользовательские типы *TypeScript* и даны их описания.
****

.Пользовательские типы TypeScript и их описания
[[table_2_anchor]]
[cols="^.^25,.^75"]
|===
| Ключевое слово | Описание

| *Массив* (`array`) и *Кортеж* (`tuple`) | Эти типы позволяют хранить множеству несколько значений в заданной последовательности. Массив состоит из элементов одного типа, а кортеж может содержать значения нескольких разных типов. Для обращения к каждому элементу массива используется метод *TypeScript* `forEach()`.
| *Перечисление* (`enum`) | Как и в *C#*, *enum* дает возможность присвоить удобочитаемые имена последовательности числовых значений.
| *Объединение* (`union`) | Начиная с *TypeScript 1.4* можно комбинировать типы, благодаря чему переменная может принимать значение, относящееся к одному из них.
| *Объект* (`object`) | Представляет собой любое значение, не относящееся к примитивному типу.
|===

==== Литералы типов

****
Типами в *TypeScript* могут быть не только строки вообще (`string`) или числа вообще (`number`). Конкретное число или конкретная строка тоже может быть типом. Например, типом может быть *«8»*, а может быть *«красный»*. Если переменная объявлена с литералом типа, то она не может принимать никакие другие значения.

{empty} +

Рассмотрим это на примере кода:
****

[source, typescript]
----
let red:"красный" = "красный";
red = "красный";
red = "зеленый";
----

****
При попытке его скомпилировать получим ошибку:
****

****
.Ошибка компеляции
[[typescript_3_anchor]]
[%collapsible%open]
====
image::typescript_3.png[title="Ошибка компеляции", align=center]
====
****

****
И для чего же нужна переменная с уникальным типом и единственным значением? Сама по себе она не особо полезна. Дело в применении. Например, в *CSS* есть свойства, которые принимают лишь несколько определенных значений. Свойство *alignment* может принимать значения *left*, *right* или *center*.
Если объединить литералы типов *left*, *right* и *center* (которые объявлены как строки) в *union*, то получим двойную пользу:

{empty} +

====
* Будут приниматься лишь допустимые значения
* Они будут передаваться в виде строк, которые можно вставить в код (не нужно ветвление, чтобы сопоставить значения из объединения со строковыми значениями)
====

Наглядно это будет выглядеть так:
****

[source, typescript]
----
function setText(msg: string, alignment: "left" | "right" | "center") {
 // ...
}
setText("Готово!", "left");
setText("Ошибка!", "bottom");
----

.*Компилятор не дает ошибиться!*
****
.Компилятор не дает ошибиться!
[[typescript_4_anchor]]
[%collapsible%open]
====
image::typescript_4.png[title="Компилятор не дает ошибиться!", align=center]
====
****

==== Шаблоны литералов типов

****
****

==== Классы

==== Объявление класса

==== Создание экземпляра класса

==== Доступ к полям и функциям

=== Пространства имен

==== Возможности пространств имен в TypeScript

=== Модули

=== Совместимость с JavaScript. Окружение (Ambient)

== Преимущества и недостатки TypeScript

== Итоги