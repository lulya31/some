---
title: "Vue JS"
description: "Описание Vue JS"
weight: 1
draft: false
---

:toc: auto
:toc-title: Содержание
:toclevels: 5
:doctype: book
:icons: font
:figure-caption: Рисунок
:source-highlighter: pygments
:pygments-css: style
:pygments-style: monokai
:includedir: ./content/

:imgdir: /02_01_05_01_img/
:imagesdir: {imgdir}
ifeval::[{exp2pdf} == 1]
:imagesdir: static{imgdir}
:includedir: ../
endif::[]

:imagesoutdir: ./static/02_01_05_01_img/

= Vue JS

{empty} +

****
*Vue* (произносится /vjuː/, примерно как *view*) — это прогрессивный фреймворк для создания пользовательских интерфейсов. В отличие от фреймворков-монолитов, *Vue* создан пригодным для постепенного внедрения. Его ядро в первую очередь решает задачи уровня представления (*view*), что упрощает интеграцию с другими библиотеками и существующими проектами. С другой стороны, *Vue* полностью подходит и для создания сложных одностраничных приложений (*SPA*, *Single-Page Applications*), если использовать его совместно с link:https://ru.vuejs.org/v2/guide/single-file-components.html[*современными инструментами*, window=_blank] и link:https://github.com/vuejs/awesome-vue#components--libraries[*дополнительными библиотеками*, window=_blank].
****

****
Сравнение характеристик *Vue* с другими фреймворками можно найти link:https://ru.vuejs.org/v2/guide/comparison.html[*тут*, window=_blank].
****

== Декларативная отрисовка

****
В ядре *Vue.js* находится система, которая позволяет декларативно отображать данные в *DOM* с помощью простых шаблонов (см. листинги ниже)
****

[source, html]
----
<div id="app">
    {{ message }}
</div>
----

[source, javascript]
----
var app = new Vue({
    el: '#app',
    data: {
        message: 'Привет, Vue!'
    }
})
----

[source, text]
----
Привет, Vue!
----

****
Мы и создали наше первое *Vue*-приложение! Выглядит как простая отрисовка шаблона, но _под капотом_ *Vue* выполнил немало работы. Данные и *DOM* теперь реактивно связаны. Как это проверить? Просто откройте консоль *JavaScript* в браузере (прямо здесь, на этой странице) и задайте свойству `[.red]#app.message#` новое значение. Вы тут же увидите соответствующее изменение в браузере.
****

****
Обратите внимание, что теперь больше не нужно напрямую взаимодействовать с *HTML*. Приложение *Vue* присоединяется к одному элементу *DOM* (`#app` в данном случае), а затем полностью контролирует его. *HTML* является нашей точкой входа, но всё остальное происходит внутри вновь созданного экземпляра *Vue*.
****

****
Кроме интерполяции текста, можно также связывать атрибуты элементов:
****

[source, html]
----
<div id="app-2">
    <span v-bind:title="message">
        Наведи на меня курсор на пару секунд,
        чтобы увидеть динамически связанное значение title!
    </span>
</div>
----

[source, javascript]
----
var app2 = new Vue({
    el: '#app-2',
    data: {
        message: 'Вы загрузили эту страницу: ' + new Date().toLocaleString()
    }
})
----

[source, text]
----
Наведи на меня курсор на пару секунд, чтобы увидеть динамически связанное значение title!
----

****
Здесь мы встречаемся с чем-то новым. Атрибут `[.red]#v-bind#`, называется директивой. Директивы имеют префикс `[.red]#v-#`, указывающий на их особую природу. Как вы уже могли догадаться, они добавляют к отображаемому *DOM* особое реактивное поведение, управляемое *Vue*. В данном примере директива говорит: [.yellow-background]#*сохраняй значение title этого элемента актуальным при изменении свойства message в экземпляре Vue*#.
****

****
Откройте консоль *JavaScript* и введите `[.red]#app2.message = 'новое сообщение'#`, вы увидите как связанный код *HTML* — в нашем случае, атрибут `[.red]#title#` — обновился.
****

== Условия и циклы

****
Управлять присутствием элемента в *DOM* тоже довольно просто:
****

[source, html]
----
<div id="app-3">
    <span v-if="seen">Сейчас меня видно</span>
</div>
----

[source, javascript]
----
var app3 = new Vue({
    el: '#app-3',
    data: {
        seen: true
    }
})
----

[source, text]
----
Сейчас меня видно
----

****
Попробуйте ввести в консоли `[.red]#app3.seen = false#`. Сообщение пропадёт.

{empty} +

Этот пример демонстрирует возможность связывать данные не только с текстом и атрибутами, но и со структурой *DOM*. Более того, *Vue* также имеет мощную систему анимации, которая автоматически применяет эффекты переходов, когда элементы *добавляются/обновляются/удаляются*.

{empty} +

Есть и другие директивы, каждая из которых имеет своё предназначение. Например, директива v-for для отображения списков, используя данные из массива:
****

[source, html]
----
<div id="app-4">
    <ol>
        <li v-for="todo in todos">
            {{ todo.text }}
        </li>
    </ol>
</div>
----

[source, javascript]
----
var app4 = new Vue({
    el: '#app-4',
    data: {
        todos: [
            { text: 'Изучить JavaScript' },
            { text: 'Изучить Vue' },
            { text: 'Создать что-нибудь классное' }
        ]
    }
})
----

[source, text]
----
1. Изучить JavaScript
2. Изучить Vue
3. Создать что-нибудь классное
----

****
Введите в консоли `[.red]#app4.todos.push({ text: 'Profit' })#`. Вы увидите, что к списку добавится новый элемент.
****

== Работа с пользовательским вводом

****
Чтобы пользователи могли взаимодействовать с вашим приложением, используйте директиву `[.red]#v-on#` для отслеживания событий, указав метод-обработчик:
****

[source, html]
----
<div id="app-5">
    <p>{{ message }}</p>
    <button v-on:click="reverseMessage">Перевернуть сообщение</button>
</div>
----

[source, javascript]
----
var app5 = new Vue({
    el: '#app-5',
    data: {
        message: 'Привет, Vue.js!'
    },
    methods: {
        reverseMessage: function () {
            this.message = this.message.split('').reverse().join('')
        }
    }
})
----

****
.Пример (ДО нажатия на кнопку 'Перевернуть сообщение')
[[example_1_anchor]]
[%collapsible%open]
====
image::example_1.png[title="Пример (ДО нажатия на кнопку 'Перевернуть сообщение')", align=center]
====
****

****
.Пример (ПОСЛЕ нажатия на кнопку 'Перевернуть сообщение')
[[example_2_anchor]]
[%collapsible%open]
====
image::example_2.png[title="Пример (ПОСЛЕ нажатия на кнопку 'Перевернуть сообщение')", align=center]
====
****

****
Обратите внимание, в методе мы просто обновляем состояние приложения, не затрагивая *DOM* — всю работу с *DOM* выполняет *Vue*, а вы пишете код, который занимается только логикой приложения.

{empty} +

*Vue* также предоставляет директиву `[.red]#v-model#`, позволяющую легко связывать элементы форм и состояние приложения:
****

[source, html]
----
<div id="app-6">
    <p>{{ message }}</p>
    <input v-model="message">
</div>
----

[source, javascript]
----
var app6 = new Vue({
    el: '#app-6',
    data: {
        message: 'Привет, Vue!'
    }
})
----

****
.Пример (обновременно с пользовательским вводом меняется текст выше поля ввода) - видим default-ое значение: Привет!
[[example_3_anchor]]
[%collapsible%open]
====
image::example_3.png[title=".Пример (обновременно с пользовательским вводом меняется текст выше поля ввода) - видим default-ое значение: Привет!", align=center]
====
****

****
.Пример (обновременно с пользовательским вводом меняется текст выше поля ввода) - видим измененное значение: Привет Алексей!
[[example_4_anchor]]
[%collapsible%open]
====
image::example_4.png[title="Пример (обновременно с пользовательским вводом меняется текст выше поля ввода) - видим измененное значение: Привет Алексей!", align=center]
====
****

== Разбиение приложения на компоненты

****
Важной концепцией *Vue* являются компоненты. Эта абстракция позволяет собирать большие приложения из маленьких «кусочков». Они представляют собой пригодные к повторному использованию объекты. Если подумать, почти любой интерфейс можно представить как дерево компонентов:
****

****
.Разбиение приложения на компоненты
[[components_anchor]]
[%collapsible%open]
====
image::components.png[title="Разбиение приложения на компоненты", align=center]
====
****

****
Во *Vue* компонент — это, по сути, экземпляр *Vue* с предустановленными опциями. Создать новый компонент во *Vue* просто:
****

[source, javascript]
----
// Определяем новый компонент под именем todo-item
Vue.component('todo-item', {
    template: '<li>Это одна задача в списке</li>'
})

var app = new Vue(...)
----

****
Теперь его можно использовать в шаблоне другого компонента:
****

[source, html]
----
<ol>
    <!-- Создаём экземпляр компонента todo-item -->
    <todo-item></todo-item>
</ol>
----

****
Пока что у нас получилось так, что во всех элементах списка будет один и тот же текст — это не очень-то интересно. Хотелось бы иметь возможность передавать данные от родительского в дочерние компоненты. Давайте изменим определение компонента, чтобы он мог принимать link:https://ru.vuejs.org/v2/guide/components.html#%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B2-%D0%B4%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B[*входной параметр*, window=_blank]:
****

[source, javascript]
----
Vue.component('todo-item', {
    // Компонент todo-item теперь принимает
    // "prop", то есть входной параметр.
    // Имя входного параметра todo.
    props: ['todo'],
    template: '<li>{{ todo.text }}</li>'
})
----

****
Теперь можно передать текст задачи в каждый компонент с помощью `[.red]#v-bind#`:
****

[source, html]
----
<div id="app-7">
    <ol>
        <!--
        Теперь мы можем передать каждому компоненту todo-item объект
        с информацией о задаче, который будет динамически меняться.
        Мы также определяем для каждого компонента "key",
        значение которого мы разберём далее в руководстве.
        -->
        <todo-item
            v-for="item in groceryList"
            v-bind:todo="item"
            v-bind:key="item.id"
        ></todo-item>
    </ol>
</div>
----

[source, javascript]
----
Vue.component('todo-item', {
    props: ['todo'],
    template: '<li>{{ todo.text }}</li>'
})

var app7 = new Vue({
    el: '#app-7',
    data: {
        groceryList: [
        { id: 0, text: 'Овощи' },
        { id: 1, text: 'Сыр' },
        { id: 2, text: 'Что там ещё люди едят?' }
        ]
    }
})
----

[source, text]
----
1. Овощи
2. Сыр
3. Что там еще люди едят?
----

****
Конечно, этот пример слегка надуман, но посмотрите сами — мы разделили наше приложение на два меньших объекта, и дочерний, в разумной мере, отделён от родительского с помощью интерфейса входных параметров. Теперь можно улучшать компонент `[.red]#<todo-item>#`, усложнять его шаблон и логику, но не влиять на родительское приложение.

{empty} +

В крупных приложениях разделение на компоненты становится обязательным условием для сохранения управляемости процесса разработки. Разговор о компонентах ещё далеко не окончен и мы вернёмся к ним позднее в этом руководстве, но уже сейчас можно взглянуть на (вымышленный) пример того, как может выглядеть шаблон приложения, использующего компоненты:
****

[source, html]
----
<div id="app">
    <app-nav></app-nav>
    <app-view>
        <app-sidebar></app-sidebar>
        <app-content></app-content>
    </app-view>
</div>
----

=== Отношение к пользовательским элементам Web Components

****
Вы могли заметить, что компоненты *Vue* довольно похожи на *пользовательские элементы*, являющиеся частью link:https://www.w3.org/wiki/WebComponents/[*спецификации W3C Web Components*, window=_blank]. Дело в том, что синтаксис компонентов *Vue* и правда намеренно следует этой спецификации. В частности, компоненты *Vue* реализуют link:https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md[*API слотов*, window=_blank] и специальный атрибут `[.red]#is#`. Но есть и несколько ключевых различий:

. Спецификация *Web Components* была завершена, но она реализована ещё не во всех браузерах. *Safari 10.1+*, *Chrome 54+* и *Firefox 63+* уже поддерживают веб-компоненты. Компоненты *Vue*, напротив, не требуют никаких полифилов и работают во всех поддерживаемых браузерах (*IE9* и выше). При необходимости компоненты *Vue* могут быть *"обёрнуты"* в нативные пользовательские элементы.

. Компоненты *Vue* предоставляют возможности, недоступные в простых пользовательских элементах. Самые значимые из них: кросс-компонентная передача данных, коммуникация с использованием пользовательских событий и интеграция с инструментами сборок.
****

== Ссылки на официальный сайт фреймворка Vue JS

****
В данной статье кратко описаны самые основные возможности ядра *Vue.js*. Более подробную информацию можно увидеть на официальном link:https://ru.vuejs.org/[*сайте фреймворка*, window=_blank].
****
