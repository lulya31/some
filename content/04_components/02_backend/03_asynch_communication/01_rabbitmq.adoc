---
title: "RabbitMQ - Сервис очередей"
description: "RabbitMQ - Сервис очередей"
weight: 1
draft: false
Categories:
    - Architecture
    - Backend
Tags:
    - Async communications
    - RabbitMQ
---

:imgdir: /04_02_03_01_img/
:imagesoutdir: ./static/04_02_03_01_img/

include::static/includes/init.adoc[]



= Сервис очередей RabbitMQ

{empty} +

****
Сервис очередей *RabbitMQ* реализует в проекте *Rolf* обмен данными между link:/02_architecture/02_backend/05_internal_systems_rolf/02_rose_1c/[*ROSE 1C*, window=_blank] и link:/02_architecture/02_backend/11_platformeco/[*Platformeco*, window=_blank].
****
****
*RabbitMQ* - это система очереди сообщений. Очередь сообщений в свою очередь предоставляет способ асинхронного взаимодействия между различными компонентами системы. *RabbitMQ* использует протокол *AMQP*. *AMQP* - это открытый протокол, который определяет, как система должна обмениваться сообщениями. Он устанавливает правила, которыми должны следовать системы, которые собираются взаимодействовать друг с другом. В дополнении к описанию способа взаимодействия между системами и брокером, он также стандартизирует команды и сообщения, которыми обмениваются системы. Так как *AMQP* написано на открытом коде, его сообщество довольно большое и на нём реаливаны брокеры и клиентские части на многих языках программирования.
****

== Концепции AMQP

****
====
- *Брокер сообщений* - это часть приложения, которое получает сообщения от одного приложеня и доставляет другому.
- *Виртуальный хост* - это часть брокера. Является способом разделения приложений, которые используют один *RabbitMQ*. Например, вы можете разделить по виртуальным хостам *dev* и *staging* окружение, чтобы они были изолированными друг от друга. Пользователи, обмен сообщениями, очереди - всё это изолировано на виртуальном хосте. Пользователь, подсоединённый к определённому хосту, не может видеть данные в другом хосте.
- *Соединение* - это физическое соединение по протоколу *TCP* между приложениями и брокером. Когда клиент отсоединяется или система вылетает с ошибкой, соединение закрывается.
- *Канал* - это виртуальное соединение внутри соединения. Он переиспользует существующее соединение, чтобы сэкономить на ресурсах и не заствлять системы устанавливать новое соединение. Когда происходит публикация или запрос нового сообщения, весь процесс происходит внутри существующего соединения.
- *Обмен* - это применение таких правил к сообщеням, по которым они достигают места назначения. Другими словами, процесс обмена удостоверяется, что полученное сообщение приходит в конкретную очередь. В какую очередь попадает сообщение зависит от правил, определённых для этого типа сообщений. Очередь должна быть привязана как минимум к одному обмену, чтобы получать сообщения.
- *Очередь* - это упорядоченный список сообщений. Очередь существует внутри брокера.
- *Связь* - это виртуальное соединение между обменом и очередью внутри брокера. Она позволяет сообщениям перетекать из обмена в очередь.
====
****

*RabbitMQ* - это реализация *AMQP* на языке *Erlang*. Этот язык был выбран не случайно, он позволяет создавать распределённые и устойчивые приложения. Приложение может запускаться на любых операционных системах.

{empty} +

В качестве хранения данных *RabbitMQ* использует *Mnesia* - это база данных, которая производит обработку данных как в памяти, так и на диске, тоже написана на *Erlang*. *Mnesia* хранит информацию о пользователях, обмене, очередят, связях и т.д. Индекс очереди хранит положение сообщения и информацию о том, было ли оно доставлено или нет.

== Сценарии использования RabbitMQ

Очереди сообщений часто используются в микросервисной архитектуре. Но что это означает? +
Микросервисная архитектура разделяет приложение на мелкие сервисы и само приложение является суммой всех микросервисов. Сервисы не соединены друг с другом напрямую. Вместо этого они используют очередь сообщений. Один сервис в асинхронном режиме отправляет сообщение в очередь, а другой его получает. +
Другой пример использования *RabbitMQ* - это события и задачи. +
События, задачи, уведомления говорят приложению, что что-то произошло. Одно приложение может подписаться на события от другого и делать необходимые операции.

{empty} +

====
*Пример:* Представьте обычную социальную сеть. Если один пользователь публикует пост, то его друзья, у которых включено уведомление, должны увидеть этот пост в своей ленте. Эта операция является довольно ресурсоёмкой, поэтому имеет смысл событие о публикации поста вынести в очередь. И затем обработать его в асинхронном режиме, распределив пост между друзьями пользователя.
====