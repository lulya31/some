---
title: "Паттерн - База данных на сервис"
description: "Паттерн - База данных на сервис"
weight: 2
draft: false
Categories:
    - Architecture
    - Patterns    
Tags:
    - Data per service
---

:imgdir: /04_03_02_img/
:imagesoutdir: ./static/04_03_02_img/

include::static/includes/init.adoc[]



= Паттерн - База данных на сервис

{empty} +

== Контекст

****
Разрабатываем приложение интернет-магазина с использованием link:/02_architecture/03_patterns/03_microservice_architecture/[*паттерна архитектуры Microservice*, window=_blank]. Большинству служб необходимо сохранять данные в какой-либо базе данных. Например, база `[.red]#*Order Service*#` хранит информацию о заказах, а `[.red]#*Customer Service*#` хранит информацию о покупателях.
****

****
.Сервисы и базы данных
[[customersandorders_anchor]]
[%collapsible%open]
====
image::customersandorders.png[title="Сервисы и базы данных", align=center]
====
****

== Проблема

****
Какова архитектура базы данных в приложении микросервисов?
****

== Преимущества

****
* Сервисы должны быть слабо связаны, чтобы их можно было разрабатывать, развертывать и масштабировать независимо друг от друга.
* Некоторые бизнес-транзакции должны применять инварианты, охватывающие несколько служб. Например, `[.red]#*Place Order*#` вариант использования должен удостовериться, что новый Заказ не превысит кредитный лимит клиента. Другие бизнес-транзакции должны обновлять данные, принадлежащие нескольким службам.
* Некоторые бизнес-транзакции должны запрашивать данные, принадлежащие нескольким службам. Например, при `[.red]#*View Available Credit*#` использовании необходимо запросить `[.red]#*Customer*#`, чтобы найти `[.red]#*creditLimit*#` и `[.red]#*Orders*#`, чтобы рассчитать общую сумму открытых ордеров.
* Некоторые запросы должны объединять данные, принадлежащие нескольким службам. Например, для поиска клиентов в определенном регионе и их последних заказов требуется объединение клиентов и заказов.
* Базы данных иногда необходимо реплицировать и сегментировать для масштабирования. См. Масштабный куб.
* Разные сервисы предъявляют разные требования к хранению данных. Для некоторых служб реляционная база данных является лучшим выбором. Другим службам может потребоваться база данных *NoSQL*, такая как *MongoDB*, которая хороша для хранения сложных неструктурированных данных, или *Neo4J*, которая предназначена для эффективного хранения и запроса графических данных.
****

== Решение

****
Нужно держать постоянные данные каждой микрослужбы закрытыми и доступными только через ее *API*. Транзакции службы включают только ее базу данных. +
На следующей диаграмме показана структура этого шаблона.
****

****
.Структура шаблона
[[databaseperservice_anchor]]
[%collapsible%open]
====
image::databaseperservice.png[title="Структура шаблона", align=center]
====
****

****
База данных службы фактически является частью реализации этой службы. Другие службы не могут получить к нему прямой доступ. +
Существует несколько различных способов сохранить конфиденциальность постоянных данных службы. Вам не нужно выделять сервер базы данных для каждой службы. Например, если вы используете реляционную базу данных, возможны следующие варианты:

====
* *Private-tables-per-service* — каждая служба владеет набором таблиц, доступ к которым должен иметь только этот сервис.
* *Схема для каждой службы* - каждая служба имеет схему базы данных, которая является частной для этой службы.
* *База данных-сервер-для-службы* — каждая служба имеет свой собственный сервер базы данных.
====

Частные таблицы для каждой службы и схема для каждой службы имеют наименьшие накладные расходы. Использование схемы для каждой службы привлекательно, поскольку делает более ясным право собственности. Некоторым службам с высокой пропускной способностью может потребоваться собственный сервер базы данных.

{empty} +

Хорошей идеей является создание ограничений, поддерживающих эту модульность. Вы можете, например, назначить разные идентификаторы пользователей базы данных для каждой службы и использовать механизм управления доступом к базе данных, такой как гранты. Без какого-либо ограничения для принудительной инкапсуляции у разработчиков всегда будет соблазн обойти *API* сервиса и получить прямой доступ к его данным.
****

== Результат

.*Использование базы данных для каждой службы имеет следующие преимущества:*
****
* Помогает обеспечить слабую связанность сервисов. Изменения в базе данных одной службы не влияют на другие службы.
* Каждая служба может использовать тот тип базы данных, который лучше всего подходит для ее нужд. Например, служба, выполняющая текстовый поиск, может использовать *ElasticSearch*. Сервис, который манипулирует социальным графом, может использовать *Neo4j*.
****


.*Использование базы данных для каждой службы имеет следующие недостатки:*
****
* Реализация бизнес-транзакций, охватывающих несколько сервисов, непроста. Распределенных транзакций лучше избегать из-за теоремы *CAP*. Более того, многие современные (*NoSQL*) базы данных их не поддерживают.
* Реализация запросов, которые объединяют данные, которые сейчас находятся в нескольких базах данных, является сложной задачей.
* Сложность управления несколькими базами данных *SQL* и *NoSQL*.
****

.*Существуют различные шаблоны/решения для реализации транзакций и запросов, которые охватывают сервисы:*
****
* Реализация транзакций, охватывающих сервисы — используйте link:/02_architecture/03_patterns/01_saga/[*шаблон Saga*, window=_blank].
* Реализация запросов, которые охватывают сервисы:
** link:https://microservices.io/patterns/data/api-composition.html[*API Composition*, window=_blank] — соединение выполняет приложение, а не база данных. Например, служба (или шлюз *API*) может получить клиента и его заказы, сначала извлекая клиента из службы поддержки клиентов, а затем запрашивая службу заказов, чтобы вернуть самые последние заказы клиента.
** link:https://microservices.io/patterns/data/cqrs.html[*Command Query Responsibility Segregation (CQRS)*, window=_blank] — поддержка одного или нескольких материализованных представлений, содержащих данные из нескольких служб. Представления хранятся службами, которые подписываются на события, которые каждая служба публикует при обновлении своих данных. Например, интернет-магазин может реализовать запрос, который находит клиентов в определенном регионе и их последние заказы, сохраняя представление, объединяющее клиентов и заказы. Представление обновляется службой, которая подписывается на события клиентов и заказов.
****

== Связанные шаблоны

****
Шаблон микросервисной архитектуры (link:/02_architecture/03_patterns/03_microservice_architecture/[*Microservice architecture pattern*]) создает потребность в этом шаблоне
Шаблон link:/02_architecture/03_patterns/01_saga/[*шаблон Saga*, window=_blank] — полезный способ реализовать в конечном итоге согласованные транзакции.
Шаблон link:https://microservices.io/patterns/data/api-composition.html[*API Composition*, window=_blank] и link:https://microservices.io/patterns/data/cqrs.html[*Command Query Segregation Responsibility Segregation (CQRS)*, window=_blank] — полезные способы реализации запросов.
link:https://microservices.io/patterns/data/shared-database.html[*Антишаблон Shared Database*, window=_blank] описывает проблемы, возникающие в результате совместного использования микросервисами базы данных.
****